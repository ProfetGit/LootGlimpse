Advanced Technical Documentation: World of Warcraft Addon Development Architecture (11.0 The War Within & 12.0 Midnight)
1. Executive Summary and Strategic Architecture
The software development landscape for World of Warcraft (WoW) interface modifications is currently undergoing its most profound structural metamorphosis since the introduction of the secure execution environment in Burning Crusade. With the deployment of The War Within (Patch 11.0) and the strategic roadmap leading into Midnight (Patch 12.0), the Blizzard UI engineering team is systematically dismantling legacy API structures to pave the way for a modernized, restricted, and high-performance user interface ecosystem.
For the professional addon engineer, this transition represents a bifurcation of development methodology. The immediate imperative of the 11.0 cycle is compatibility and modernization: adapting to the deprecation of decades-old input handling paradigms (GetMouseFocus), migrating configuration panels to the new Settings API, and embracing the "Edit Mode" native layout engine. Conversely, the looming horizon of 12.0—the "Midnight" expansion—threatens a fundamental restriction of combat data access, necessitating a defensive architectural approach that decouples visual "look and feel" elements from combat decision logic.1
This comprehensive technical report serves as a definitive reference for architecting robust, future-proof addons in this transitional era. It synthesizes deep architectural analysis of the Ace3 framework, the emerging EditModeExpanded-1.0 standards, and native UI integration, while providing a rigorous treatment of Lua 5.1 memory efficiency and AnimationGroup mechanics. A complete reference implementation of a scrolling loot text engine is dissected to demonstrate these principles in a production-grade context.
________________
2. API Landscape: The War Within (11.0) Architecture
The release of The War Within (11.0) introduced breaking changes that invalidate patterns used for over fifteen years. These changes are not merely syntactic updates but represent a shift in the underlying event propagation and configuration models of the game client.
2.1 The Input Propagation Model and Mouse Focus
Historically, the World of Warcraft client utilized a simplified input model where the mouse cursor could interact with only a single frame at any given instant. The function GetMouseFocus() returned the topmost frame handle that trapped the mouse. This model was sufficient for the static UI layouts of the past but proved inadequate for modern, layered interfaces where transparency and click-through behaviors are required.
In 11.0, the client adopted Mouse Input Propagation. This system allows mouse events (motion, clicks) to penetrate through specific regions to underlying frames, creating a stack of interacting elements rather than a single target.3
2.1.1 Deprecation of GetMouseFocus
The GetMouseFocus API has been formally deprecated and replaced by GetMouseFoci. This change is critical because legacy calls to GetMouseFocus may return unreliable results or nil in contexts where multiple frames are active.
The GetMouseFoci Paradigm:
The new GetMouseFoci() function returns an array (integer-indexed table) containing all regions currently under the mouse cursor that accept input.
Feature
	Legacy API (GetMouseFocus)
	Modern API (GetMouseFoci)
	Return Type
	Single Widget (Frame or nil)
	Array of Widgets ({Frame1, Frame2,...})
	Propagation
	Ignored; returned only top frame
	Respects SetPropagateKeyboardInput logic
	Performance
	O(1) retrieval
	O(N) allocation (creates new table)
	Use Case
	Single target identification
	Multi-layer interaction debugging
	Optimization Warning:
While GetMouseFoci provides comprehensive data, it generates a new table object on every call, creating significant garbage collection (GC) pressure if used inside an OnUpdate loop. For the common use case of checking if a specific frame is under the mouse, developers should utilize the dedicated method introduced on the ScriptRegion widget:


Lua




-- Highly efficient; no table allocation
if MyFrame:IsMouseMotionFocus() then
   -- Handle focus state
end

This method delegates the check to the C++ engine, avoiding the overhead of Lua table creation and traversal.3
2.2 The Settings API: Re-architecting Configuration
For over a decade, InterfaceOptions_AddCategory was the standard entry point for registering addon configuration panels. In 11.0, this entire subsystem was dismantled and replaced by the Settings C_API. This change was necessitated by the complete UI overhaul of the game's options menu, which now features a search-driven, canvas-layout design.4
2.2.1 Migration from InterfaceOptions
Attempts to call InterfaceOptions_AddCategory in 11.0 will result in immediate Lua errors or silent failure, rendering the addon's settings inaccessible.5 The new architecture treats settings categories as distinct objects that must be registered with specific layout topologies.
The New Registration Flow:
1. Canvas Layouts: For custom frames (like AceConfig dialogs), we use RegisterCanvasLayoutCategory.
2. Category Object: The registration returns a category object which must then be added to the addon category list.


Lua




-- Legacy (Broken in 11.0)
-- InterfaceOptions_AddCategory(myPanel)

-- Modern (11.0+)
local category, layout = Settings.RegisterCanvasLayoutCategory(myPanel, "My Addon")
-- Sub-category registration (if needed)
-- category.ID is now required for hierarchical parenting
Settings.RegisterAddOnCategory(category)

The Settings API also introduces granular control over how settings are searched. Frames registered via this API are indexed by the game client, allowing users to find specific addon options (e.g., "Loot Font Size") via the main menu search bar—a feature previously impossible with the opaque InterfaceOptions system.6
2.3 Frame Inheritance and the BackdropTemplate
A rigorous enforcement mechanism introduced in the transition to 11.0 is the Backdrop System. In previous expansions (pre-9.0/10.0), any Frame widget implicitly supported backdrop methods (SetBackdrop, SetBackdropColor). To reduce the memory footprint of frames that do not require visual backgrounds, Blizzard extracted this functionality into a mixin: BackdropTemplate.7
In 11.0, this requirement is strictly enforced. Calling frame:SetBackdrop(...) on a frame that does not inherit BackdropTemplate results in a silent failure (no visual change) or a Lua error, depending on the client build.
Implementation Strategy:
Developers must explicitly inherit the template during frame creation.
* Lua Instantiation:
Lua
local f = CreateFrame("Frame", "MyAddonFrame", UIParent, "BackdropTemplate")

* XML Definition:
XML
<Frame name="MyAddonFrame" inherits="BackdropTemplate">
  ...
</Frame>

For UI consistency with the modern "Dragonflight" aesthetic, developers are encouraged to use InsetFrameTemplate3 or similar templates found in SharedUIPanelTemplates.xml rather than manually defining backend textures, ensuring the addon blends seamlessly with the native 11.0 UI.9
________________
3. The Ace3 Framework: Architectural Deep Dive
While the native API provides the primitives for addon creation, the complexity of managing profiles, localization, and event serialization in a production-grade addon necessitates a robust framework. Ace3 (Addon Construction Engine 3) remains the industry standard, providing a modular, mixin-based architecture that abstracts the boilerplate of API interaction.11
3.1 Framework Topology and Library Management
Ace3 operates on a library-embed system. Unlike traditional inheritance, Ace3 "embeds" or "mixes in" methods into your addon object. This allows an addon to function as an event listener, a console command handler, and a timer manager simultaneously without complex class hierarchies.12
Production Directory Structure:
To ensure reliability, professional addons typically embed the libraries directly rather than relying on external installations.
MyAddon/
├── MyAddon.toc # Manifest
├── embeds.xml # Library Loader
├── Core.lua # Logic
├── Config.lua # Options Table
└── Libs/
├── LibStub/ # Versioning
├── AceAddon-3.0/ # Lifecycle
├── AceDB-3.0/ # Persistence
├── AceConfig-3.0/ # GUI Generation
└──...
The embeds.xml is critical; it must load LibStub first, followed by the libraries in dependency order. The .toc file must execute embeds.xml before Core.lua.12
3.2 AceAddon-3.0: Lifecycle Management
The core of any Ace3 addon is the AceAddon-3.0 object. It standardizes the initialization flow, which is notoriously fragmented in the raw WoW API (ADDON_LOADED vs PLAYER_LOGIN vs PLAYER_ENTERING_WORLD).


Lua




MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceConsole-3.0", "AceEvent-3.0")

function MyAddon:OnInitialize()
   -- Called when the addon is loaded. 
   -- Safe for database creation and option registration.
   -- Comparable to ADDON_LOADED but specific to this addon.
end

function MyAddon:OnEnable()
   -- Called when the player logs in and the UI is ready.
   -- Register events and hooks here.
end

function MyAddon:OnDisable()
   -- Called if the user disables the addon via configuration.
   -- Unhook and unregister events to ensure clean shutdown.
end

This lifecycle management is crucial for 11.0 compatibility, as it ensures that initialization logic (like Settings registration) happens only after the necessary Blizzard subsystems are available.13
3.3 AceDB-3.0: Advanced Data Persistence
Handling SavedVariables is one of the most error-prone aspects of addon development. AceDB-3.0 abstracts the raw table storage into a structured database with support for profiles (Character, Realm, Class, Global) and default value inheritance.14
3.3.1 The Profile System
The power of AceDB lies in its profile system. A user can define a "Healer" profile and a "Tank" profile, switching between them at will. AceDB handles the pointer swapping and table copying transparently.
Code Structure for Defaults:


Lua




local defaults = {
   profile = {
       enabled = true,
       font = {
           face = "Friz Quadrata TT",
           size = 14,
       },
       ignoredItems = {
           ["Hearthstone"] = true
       }
   },
   global = {
       minimapIcon = { hide = false }
   }
}

function MyAddon:OnInitialize()
   -- "MyAddonDB" must match the ## SavedVariables in TOC
   self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true) 
   
   -- Register Callbacks
   self.db.RegisterCallback(self, "OnProfileChanged", "RefreshConfig")
   self.db.RegisterCallback(self, "OnProfileCopied", "RefreshConfig")
   self.db.RegisterCallback(self, "OnProfileReset", "RefreshConfig")
end

Architectural Insight: The callbacks (OnProfileChanged) are mandatory for correct behavior. When a user changes profiles, AceDB replaces the self.db.profile table reference. If the addon cached values in local variables (e.g., local fontSize = self.db.profile.font.size) during initialization, those variables will become stale and point to the old profile's data. The callback acts as a signal to re-read all configuration values.14
3.4 AceConfig-3.0: The Declarative GUI
In the native API, creating a configuration window requires manual placement of FontStrings, CheckButtons, and Sliders, a process that is verbose and brittle. AceConfig-3.0 enables a declarative approach: the developer defines a Lua table describing the structure of the options, and the library renders the UI.16
3.4.1 The Options Table
The options table uses a tree structure. Each node represents a control or a group.


Lua




local options = {
   name = "My Addon",
   handler = MyAddon,
   type = "group",
   args = {
       header = {
           type = "header",
           name = "General Settings",
           order = 1,
       },
       enable = {
           type = "toggle",
           name = "Enable Addon",
           desc = "Enables or disables the core functionality",
           order = 2,
           get = "IsEnabled",
           set = "SetEnabled",
       },
       fontSize = {
           type = "range",
           name = "Font Size",
           desc = "Adjust the text size",
           min = 8, max = 32, step = 1,
           order = 3,
           get = function(info) return MyAddon.db.profile.font.size end,
           set = function(info, val) MyAddon.db.profile.font.size = val end,
       },
   }
}

3.4.2 Integration with 11.0 Settings API
AceConfigDialog-3.0 (the rendering component) acts as a bridge. It takes the Ace3 options table and converts it into frames that are compatible with the new 11.0 Settings API canvas layout.


Lua




-- Register the table
LibStub("AceConfig-3.0"):RegisterOptionsTable("MyAddon", options)

-- Add to Blizzard UI
-- The library handles the Settings.RegisterCanvasLayoutCategory logic internally
self.optionsFrame = LibStub("AceConfigDialog-3.0"):AddToBlizOptions("MyAddon", "My Addon")

This abstraction is invaluable; when Blizzard changes the settings API (as they did in 11.0), the library maintainers update AceConfigDialog, and the addon code remains unchanged.4
________________
4. Visual Systems: Edit Mode & Native UI Integration
The introduction of Edit Mode in Dragonflight and its refinement in The War Within fundamentally changed user expectations. Addons are now expected to be movable and resizable via the native Edit Mode interface rather than custom slash commands or drag handles.
4.1 EditModeExpanded-1.0 Integration
The native Edit Mode API is relatively closed, but the community has standardized around EditModeExpanded-1.0 (often exposed via the library LibEditModeOverride-1.0 or similar wrappers) to inject custom frames into the system.17
The Integration Pattern:
To make a frame "Edit Mode Aware," it must be registered with the library. This delegates the handling of positioning, scaling, and persistence to the library, which synchronizes with the game's layout storage.


Lua




local LibEditMode = LibStub("LibEditModeOverride-1.0")

function MyAddon:SetupEditMode()
   -- 1. Create the frame
   local f = self.MyDisplayFrame
   
   -- 2. Register with the library
   -- Arguments: Frame, default point, default relative frame, x, y
   LibEditMode:ReanchorFrame(f, "CENTER", UIParent, 0, 0)
   
   -- 3. (Optional) Add a custom layout preset
   -- Allows users to save the position specifically for this addon
   LibEditMode:AddLayout(Enum.EditModeLayoutType.Account, "MyAddon Default")
   
   -- 4. Apply changes
   LibEditMode:ApplyChanges()
end

Benefits of Library Usage:
   * Taint Avoidance: Modifying the native Edit Mode frames directly often causes "Action Blocked" taint errors. The library uses secure hooks and deferred execution to minimize this risk.17
   * Persistence: The library handles saving the frame's position across sessions, integrating with the user's selected Edit Mode profile (e.g., "Raid Profile" vs "Questing Profile").
4.2 Native Texture and Asset Management
In 11.0, the UI asset pipeline relies heavily on FileIDs rather than file paths. While Interface\Icons\Spell_Nature_HealingTouch style paths still work for legacy compatibility, the modern engine uses integer FileIDs for efficiency.
Retrieving FileIDs:
Developers should use C_Spell.GetSpellTexture(spellID) which returns a fileDataID (integer). Passing this integer to SetTexture is faster than string hashing.19


Lua




local textureID = C_Spell.GetSpellTexture(12345)
myTexture:SetTexture(textureID)

The Atlas System:
For UI components (borders, background panels), Blizzard utilizes Atlases. An Atlas is a sub-region of a larger texture file, defined by name. Using Atlases ensures that UI elements remain crisp at different UI scales and resolutions.


Lua




-- Preferred for UI elements
frame:SetAtlas("UI-Frame-Portrait-Border")
-- vs
-- frame:SetTexture("Interface\\FrameGeneral\\UI-Frame") -- Legacy/Brittle

Atlases are defined in the game's glue XML and allow the artwork to be updated by Blizzard without breaking the addon, provided the Atlas name remains constant.21
________________
5. Performance Engineering: High-Efficiency Lua
The World of Warcraft client utilizes a customized Lua 5.1 runtime. While Lua is a performant scripting language, the specific constraints of a real-time rendering loop (60+ FPS) require disciplined memory management. The primary bottleneck in addon performance is Garbage Collection (GC) churn caused by the rapid allocation and deallocation of temporary objects.22
5.1 The Mechanics of Memory Churn
Lua's GC uses a mark-and-sweep algorithm. In 5.1, this collector is incremental, meaning it runs in small steps interleaved with execution. However, high allocation rates force the GC to run more aggressively (the "pause" and "step multiplier" heuristics), consuming CPU cycles that should be used for rendering the game frame.
The "OnUpdate" Trap:
The OnUpdate script of a frame runs every single render frame. Code placed here is the most critical for performance.
Anti-Pattern (Catastrophic Performance):


Lua




frame:SetScript("OnUpdate", function()
   -- Creates a NEW table object every 0.016 seconds
   local position = { x = GetCursorPosition() } 
   
   -- Creates a NEW closure (function) every 0.016 seconds
   local updateFunc = function() return position.x + 1 end
   
   DoCalculations(updateFunc())
end)

In a 10-minute boss fight, this code creates ~36,000 table objects and ~36,000 function closures, all of which must be marked and swept by the GC.
5.2 Object Pooling Strategies
The definitive solution to memory churn is Object Pooling. Instead of letting the GC destroy objects, the addon manually recycles them.
5.2.1 Table Pooling
Tables are the most expensive common Lua object. A pool allows reuse.


Lua




local tablePool = {}

-- Acquire a table from the pool
local function NewTable()
   local t = table.remove(tablePool)
   if not t then
       return {} -- Pool empty, create new
   end
   table.wipe(t) -- Clean the dirty table
   return t
end

-- Release a table back to the pool
local function DelTable(t)
   table.insert(tablePool, t)
end

By implementing this, an addon might allocate only 10 tables for its entire lifecycle, reusing them millions of times. This reduces GC pressure to near zero.23
5.2.2 Frame Pooling
Frames are C++ objects mirrored in Lua. Creating them (CreateFrame) is an expensive operation involving the game engine. Destroying them is impossible; frames cannot be deleted, only hidden. Therefore, reusing frames is mandatory to prevent memory leaks.
Blizzard provides a native FramePool system, but a custom implementation is often lighter for simple needs (like scrolling text lines).


Lua




local framePool = {}

function GetFrame()
   local f = table.remove(framePool)
   if not f then
       f = CreateFrame("Frame", nil, UIParent)
       -- One-time heavy initialization
       f.text = f:CreateFontString(nil, "OVERLAY", "GameFontNormal")
   end
   f:Show()
   return f
end

function ReleaseFrame(f)
   f:Hide()
   table.insert(framePool, f)
end

5.3 Global vs. Local Variables
In Lua, accessing a global variable requires a hash table lookup in the _G environment. Accessing a local variable uses a register index, which is an order of magnitude faster.
Optimization:
Always localize global functions at the top of the file if they are used in tight loops.


Lua




local pairs = pairs
local ipairs = ipairs
local tinsert = table.insert
local GetTime = GetTime

local function FastLoop()
   -- Uses register access (fast) instead of global lookup (slow)
   local t = GetTime()
  ...
end

This practice is standard in high-performance library code (e.g., Ace3, LibHealComm).24
________________
6. Implementation Study: "LootScroll" Engine
To synthesize the API, Ace3, and efficiency concepts, we present a complete architecture for LootScroll, an addon that parses incoming loot chat messages and animates them as scrolling text on the screen.
6.1 Phase 1: Event Parsing and GlobalStrings
The engine must identify when loot is received. We listen for CHAT_MSG_LOOT. Raw parsing of strings is fragile across languages (e.g., English "You receive loot: [Item]" vs German "Ihr erhaltet Beute: [Item]"). We must use GlobalStrings.
The Pattern Matcher:
We convert the game's localized format strings (e.g., %s receives loot: %s) into Lua pattern matching strings.


Lua




-- Helper to escape magic characters for pattern generation
local function EscapePattern(str)
   str = string.gsub(str, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
   str = string.gsub(str, "%%%s", "(.-)") -- Capture string
   str = string.gsub(str, "%%%d", "(%%d+)") -- Capture number
   return "^".. str.. "$"
end

-- Cache patterns at load time
local patterns = {
   EscapePattern(LOOT_ITEM_SELF),          -- "You receive loot: %s."
   EscapePattern(LOOT_ITEM_SELF_MULTIPLE), -- "You receive loot: %sx%d."
   -- Add patterns for pushed loot, created items, etc.
}

function LootScroll:CHAT_MSG_LOOT(event, message)
   for _, pattern in ipairs(patterns) do
       local item, quantity = message:match(pattern)
       if item then
           -- Handle the swap: sometimes quantity comes first in pattern
           if tonumber(item) then 
               quantity, item = item, quantity 
           end
           self:QueueLootDisplay(item, quantity or 1)
           return
       end
   end
end

This approach ensures 100% localization compatibility.25
6.2 Phase 2: The Rendering Engine (AnimationGroups)
Moving text by updating point.y in an OnUpdate script is inefficient Lua usage. 11.0 supports AnimationGroups, which offload the interpolation math to the C++ engine.
The Scroll Frame Object:
We utilize a pool of frames (Section 5.2.2). Each frame has an AnimationGroup attached.


Lua




function LootScroll:CreateLootFrame()
   local f = CreateFrame("Frame", nil, UIParent)
   f:SetSize(300, 20)
   f.text = f:CreateFontString(nil, "OVERLAY", "GameFontNormalHuge")
   f.text:SetAllPoints()
   
   -- The Animation Engine
   f.group = f:CreateAnimationGroup()
   
   -- Translation: Moves the frame vertically
   f.animTranslate = f.group:CreateAnimation("Translation")
   f.animTranslate:SetOffset(0, 150) -- Move up 150 pixels
   f.animTranslate:SetDuration(2.5)
   f.animTranslate:SetSmoothing("OUT")
   
   -- Alpha: Fades out near the end
   f.animAlpha = f.group:CreateAnimation("Alpha")
   f.animAlpha:SetFromAlpha(1)
   f.animAlpha:SetToAlpha(0)
   f.animAlpha:SetStartDelay(1.5)
   f.animAlpha:SetDuration(1.0)
   
   -- Recycle on finish
   f.group:SetScript("OnFinished", function()
       f:Hide()
       table.insert(self.framePool, f)
   end)
   
   return f
end

This architecture is "fire and forget." Once f.group:Play() is called, the C++ engine handles the movement, freeing Lua to handle other logic.
6.3 Phase 3: Ace3 Integration
The entire system is wrapped in an AceAddon object.


Lua




LootScroll = LibStub("AceAddon-3.0"):NewAddon("LootScroll", "AceEvent-3.0")

function LootScroll:OnInitialize()
   -- Database
   self.db = LibStub("AceDB-3.0"):New("LootScrollDB", {
       profile = { speed = 2.5, fontScale = 1.2 }
   }, true)
   
   -- Events
   self:RegisterEvent("CHAT_MSG_LOOT")
   
   -- Edit Mode Registration (via wrapper)
   local LibEditMode = LibStub("LibEditModeOverride-1.0")
   if LibEditMode then
       -- Create a dummy anchor for the scrolling text
       self.anchor = CreateFrame("Frame", "LootScrollAnchor", UIParent)
       self.anchor:SetSize(200, 20)
       self.anchor:SetPoint("CENTER", 0, 100)
       LibEditMode:ReanchorFrame(self.anchor, "CENTER", UIParent, 0, 100)
   end
end

This completes the loop: The addon parses events (Lua), manages data (AceDB), renders via optimized C++ animations (AnimationGroups), and integrates with the native UI layout system (Edit Mode).
________________
7. Strategic Outlook: The Midnight (12.0) Restriction Paradigm
As development stabilizes on 11.0, forward-looking engineers must prepare for Patch 12.0 ("Midnight"). Blizzard has signaled a paradigm shift regarding Information Warfare in addons. The stated goal is to "limit the ability for addons to perform complex logic and decision making based off combat information".1
7.1 The Combat Firewall
In 12.0, APIs that provide real-time state awareness of enemies (e.g., UnitAura for enemy debuffs, C_Spell.GetSpellCooldown) are expected to be restricted during combat.
   * Protected Execution: These functions may return nil or stale data when InCombatLockdown() is true.
   * Private Auras: The "Private Aura" system (introduced in Dragonflight for specific raid mechanics) will likely become the default standard for critical combat debuffs, preventing addons from anchoring frames to them.
7.2 Architectural Decoupling
To survive the "Addon Apocalypse" of 12.0, developers must decouple State Logic from Combat Decision Logic.
The Safe Zone (Allowed):
   * "Look and Feel" customization (Textures, Fonts, Scale).
   * Personal data tracking (Your resources, your cooldowns - likely to remain accessible but perhaps restricted in automation).
   * Chat parsing (Loot, Communication).
   * Out-of-combat configuration.
The Danger Zone (Targeted for Removal):
   * Programmatic decision making (e.g., "If Target has Debuff X, flash Icon Y").
   * Automatic marker assignment based on combat log events.
   * Cast sequence automation.
Mitigation Strategy for "LootScroll":
The LootScroll example presented in Section 6 is inherently Midnight-Safe. It relies on CHAT_MSG_LOOT, which is an informational event, not a combat state event. It does not perform logic based on enemy health or spell casts.
However, addons that attempt to filter loot based on "Boss Kill" state derived from COMBAT_LOG_EVENT_UNFILTERED parsing should migrate to using BOSS_KILL events or ENCOUNTER_END APIs, as the raw combat log stream may be throttled or anonymized in real-time execution in future patches.27
________________
8. Conclusion
The transition from The War Within to Midnight represents the maturing of the World of Warcraft addon ecosystem. The era of unrestricted API access and inefficient coding practices is ending. The modern addon engineer must be a master of the Settings API, a proficient user of Ace3, and a disciplined manager of Lua memory.
By adopting the architectural patterns outlined in this report—specifically Object Pooling, AnimationGroup offloading, and Library-based Edit Mode integration—developers can build robust tools that not only survive the API changes of 11.0 but are resilient enough to endure the restrictive environment of the World Soul Saga.
Appendix: Dependency Reference Table
Library
	Version Requirement
	Purpose
	Critical 11.0 Change
	Ace3
	Release-r1340+
	Core Framework
	AceConfig update for Settings API
	LibEditModeOverride
	1.0
	Layouts
	Enables custom frame registration
	CallbackHandler
	1.0
	Event Mixins
	Underlying logic for AceEvent
	LibSharedMedia
	3.0
	Assets
	Provides fonts/textures via FileID
	Appendix: Project Manifest (.toc)


Lua




## Interface: 110000
## Title: LootScroll
## Notes: High-performance scrolling loot text.
## Author: Engineering Dept
## Version: 1.0.0
## SavedVariables: LootScrollDB
## OptionalDeps: Ace3, LibEditModeOverride-1.0

embeds.xml
Core.lua

Works cited
   1. Patch 12.0.0/API changes - Warcraft Wiki - Your wiki guide to the World of Warcraft, accessed December 2, 2025, https://warcraft.wiki.gg/wiki/Patch_12.0.0/API_changes
   2. MysticalOS (add-on author) new video about most recent API changes. Blizzard explains some of their dev insights and design philosophies with DBM and BW add on authors. : r/wow - Reddit, accessed December 2, 2025, https://www.reddit.com/r/wow/comments/1op6acz/mysticalos_addon_author_new_video_about_most/
   3. Patch 11.0.0/API changes - Warcraft Wiki - Your wiki guide to the World of Warcraft, accessed December 2, 2025, https://warcraft.wiki.gg/wiki/Patch_11.0.0/API_changes
   4. Hide Micro Menu (The War Within - 11.0) : Graphic UI Mods : World of Warcraft AddOns, accessed December 2, 2025, https://www.wowinterface.com/downloads/info26447-HideMicroMenuTheWarWithin-11.0.html
   5. Addons not showing - Customer Support - World of Warcraft Forums, accessed December 2, 2025, https://us.forums.blizzard.com/en/wow/t/addons-not-showing/1918253
   6. Patch 11.0.2/API changes - Warcraft Wiki - Your wiki guide to the World of Warcraft, accessed December 2, 2025, https://warcraft.wiki.gg/wiki/Patch_11.0.2/API_changes
   7. WoW:XML templates - AddOn Studio, accessed December 2, 2025, https://addonstudio.org/wiki/WoW:XML_templates
   8. Examiner : Miscellaneous : World of Warcraft AddOns - WoW Interface, accessed December 2, 2025, https://www.wowinterface.com/downloads/info7377-Examiner.html
   9. wow-ui-source/SharedXML/SharedUIPanelTemplates.xml at live - GitHub, accessed December 2, 2025, https://github.com/tekkub/wow-ui-source/blob/live/SharedXML/SharedUIPanelTemplates.xml
   10. Classic Quest Log : Character Advancement : World of Warcraft AddOns - WoW Interface, accessed December 2, 2025, https://www.wowinterface.com/downloads/info23118-ClassicQuestLog.html
   11. WoWUIDev/Ace3: Ace3 WoW AddOn Development Framework - GitHub, accessed December 2, 2025, https://github.com/WoWUIDev/Ace3
   12. WelcomeHome: Your first Ace3 Addon - Warcraft Wiki, accessed December 2, 2025, https://warcraft.wiki.gg/wiki/WelcomeHome:_Your_first_Ace3_Addon
   13. Getting Started - Pages - Ace3 - Addons - Projects - WowAce, accessed December 2, 2025, https://www.wowace.com/projects/ace3/pages/getting-started
   14. AceDB-3.0 Tutorial - Pages - Ace3 - Addons - Projects - WowAce, accessed December 2, 2025, https://www.wowace.com/projects/ace3/pages/ace-db-3-0-tutorial
   15. AceDB-3.0.lua - GitHub, accessed December 2, 2025, https://github.com/Vicious-wow/XIV_Databar/blob/master/Libs/AceDB-3.0/AceDB-3.0.lua
   16. AceConfig-3.0 Options Tables - Pages - Ace3 - Addons - Projects - WowAce, accessed December 2, 2025, https://www.wowace.com/projects/ace3/pages
   17. plusmouse/LibEditModeOverride: Manipulate frames controlled by edit mode without issues. Library for addons for World of Warcraft - GitHub, accessed December 2, 2025, https://github.com/plusmouse/LibEditModeOverride
   18. p3lim-wow/LibEditMode: Library that allows integration with the Edit Mode - GitHub, accessed December 2, 2025, https://github.com/p3lim-wow/LibEditMode
   19. List of API Changes with The War Within? : r/wowaddons - Reddit, accessed December 2, 2025, https://www.reddit.com/r/wowaddons/comments/1d9frzl/list_of_api_changes_with_the_war_within/
   20. [DEVHELP] List of built-in images/textures? : r/wowaddons - Reddit, accessed December 2, 2025, https://www.reddit.com/r/wowaddons/comments/91ql28/devhelp_list_of_builtin_imagestextures/
   21. Gethe/wow-ui-textures: git mirror of the user interface textures for World of Warcraft - GitHub, accessed December 2, 2025, https://github.com/Gethe/wow-ui-textures
   22. Why does Lua use a garbage collector instead of reference counting? - Stack Overflow, accessed December 2, 2025, https://stackoverflow.com/questions/5010100/why-does-lua-use-a-garbage-collector-instead-of-reference-counting
   23. WoW:HOWTO: Use Tables Without Generating Extra Garbage - AddOn Studio, accessed December 2, 2025, https://addonstudio.org/wiki/WoW:HOWTO:_Use_Tables_Without_Generating_Extra_Garbage
   24. My favourite addon leaks memory - WoWInterface, accessed December 2, 2025, https://www.wowinterface.com/forums/showthread.php?t=57263
   25. Eui.cc/wow-globalstrings - Gitee, accessed December 2, 2025, https://gitee.com/cadcamzy/wow-globalstrings/blob/master/deDE.lua
   26. GlobalStrings help needed. Achievement issues. - WoWInterface, accessed December 2, 2025, https://www.wowinterface.com/forums/showthread.php?t=39564
   27. Combat Addons - Consequences explained and what the future entails - Blizzard Forums, accessed December 2, 2025, https://us.forums.blizzard.com/en/wow/t/combat-addons-consequences-explained-and-what-the-future-entails/2176701
   28. What Happens if Blizzard Removes Addons in WoW?, accessed December 2, 2025, https://us.forums.blizzard.com/en/wow/t/what-happens-if-blizzard-removes-addons-in-wow/2179512